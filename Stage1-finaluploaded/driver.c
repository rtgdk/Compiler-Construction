/*
Rohit Lodha
2015A7PS0040P
*/
#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "symbolTable.h"
#include "semantics.h"
//#include "codegen.h"
#define RED   "\x1B[31m"
#define GRN   "\x1B[32m"
#define YEL   "\x1B[33m"
#define BLU   "\x1B[34m"
#define RESET "\x1B[0m"

int main(int argc, char *argv[])
{
	if(argc!=3)
	{
		printf("%sProper Arguments not given\n",RED);
		printf(RESET);
		return 0;
	}
	int n;
	initialiseKeywordHash();
	initHashtable();
	createGrammar("grammar.txt");
	initialisefirstandfollowMatrix();
	findFirstSet();
	findFollowSet();
	initParseTable();
	createParseTable();
	createHashtable3();
	initSymbolTable();
	//printParseTable();
	// int ptdone=0;
	parsetree PT;
	AStree ast;
	printf("%s(a) FIRST and FOLLOW set automated\n(b) Both lexical and syntax analysis modules implemented and running.\n(c) Error recovery using synchronized set implemented.\n(d) Hashing used for keyword detection.\n",BLU);
	printf(RESET);
	int n1=0;
	int n2=0;
	int n3=0;
	int n4=0;
	int n5=0;
	int n6=0;
	while(1){
		printf("%s\nPress option for the defined task\n0 : To quit\n1 : For printing the token list (on the console) generated by the lexer.\n2 : For parsing to verify the syntactic correctness of the input source code\n3 : For printing AST on the console\n4 : For printing compression ratio\n5 : For printing Symbol table\n6 : For verifying syntactic and semantic correctness\nOption:",YEL);
		printf(RESET);
		scanf("%d",&n);
		if(n==1){
			initialiseLexer();
			//removeComments(argv[1]);
			printtokens(argv[1]);
			n1 = 1;
		}
		else if(n==2){
		    if(n1==1){
			    PT = parseInputSourceCode(argv[1],parsetable);
			    printf("     lexCurNode lineno          token valIfNum          parentNodeSymbol isLeaf               NodeSymbol\n");
	     		printf("--------------------------------------------------------------------------------------------------------\n");
			    printParseTree(PT);
			    n2=1;
			    }
			else{
			    printf("%sFirst run Lexer using option 1\n",RED);
			    printf(RESET); 
			}
		}
		// else if(n==4){
		// 	initialiseLexer();
		// 	FILE *fp;
	 // 		fp = fopen (argv[2],"w");
	 // 		fprintf(fp,"     lexCurNode lineno          token valIfNum          parentNodeSymbol isLeaf               NodeSymbol\n");
	 // 		fprintf(fp,"--------------------------------------------------------------------------------------------------------\n");
		// 	if(ptdone==1){
		// 		printParseTree(PT,fp);
		// 	}
		// 	else{
		// 		PT = parseInputSourceCode(argv[1],parsetable);
		// 		printParseTree(PT,fp);
		// 	}
		// 	fclose(fp);
		// 	printf("%sParse Tree written in File\n",GRN);
		// 	printf(RESET);
		// }
		else if(n==3){
		    if(n2==1){
		        //initialiseLexer();
		        //PT = parseInputSourceCode(argv[1],parsetable);
		        //printParseTree(PT);
		        makeST(PT);
		        ast = makeAST(PT);
		        printf("\n Inorder Traversal of AST\n\n");
		        printf("     lexCurNode lineno          token valIfNum          parentNodeSymbol isLeaf               NodeSymbol\n");
	     		printf("--------------------------------------------------------------------------------------------------------\n");
		        printASTree(ast);
		        n3=1;
	        }
	        else{
	             printf("%sFirst create ParserTree using option 2\n",RED);
			     printf(RESET);  
	        }
		    //printAST2(ast);
		}
		else if(n==4){
		    if(n3==1){
			    comprr();
			    n4=1;
		    }
		    else{
		        printf("%sFirst create AST using option 3\n",RED);
			    printf(RESET); 
		    }
		}
		else if(n==5){
		    //initialiseLexer();
		    //PT = parseInputSourceCode(argv[1],parsetable);
		    //printf("PT succesfull %s\n",PT->ruleNode->name);
		    //makeST(PT);
            //printf("ST succesfull\n");
            if(n3==1){
		        printSTUtility();
		        n5=1;
	        }
	        else if(n2==1){
	            makeST(PT);
	            printSTUtility();
		        n5=1;
	        }
	        else{
	            printf("%sFirst create AST using option 3\n",RED);
			    printf(RESET); 
	        }
		}
		else if(n==6){
			//initialiseLexer();
		    //PT = parseInputSourceCode(argv[1],parsetable);
		    //makeST(PT);
		    //ast = makeAST(PT);
		    if(n5==1){
		        semanticAnalysis(ast);
	        }
	        else{
	            printf("%sFirst create Symbol Table using option 5\n",RED);
			    printf(RESET); 
	        }
		}
		//else if(n==7){
		//	gen_code_util(argv[2],ast);
		//}
		// else if(n==7){
		//     initialiseLexer();
		//     PT = parseInputSourceCode(argv[1],parsetable);
		//     //printf("PT succesfull %s\n",PT->ruleNode->name);
		//     makeST(PT);
		//     ast = makeAST(PT);
		//     printSTUtility();
		   
  //           //printf("ST succesfull\n");
		//     // printSTUtility();
		// }
		else{
			printf("%sQuiting\n",RED);
			printf(RESET);
			break;
		}
	}
	return 0;
}
